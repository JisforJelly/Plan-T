## DTO 관리 
Entity가 많아지고, 그 관계가 복잡할 수록 단순 DTO의 네이밍만으로 어떤 도메인과 연관되있는지 파악하기 어렵다 생각했습니다. 

따라서 도메인과 관련된 하나의 큰 DTO로 묶고, inner class로 관리하여 응집성을 높이고자 했습니다.


## 시군구, 컨텐츠 타입 코드

사실상 거의 변화하지 않은 코드인데 매번 DB조회는 효율적이지 않다고 판단하여 별도의 enum으로 관리하였습니다.

그러나 군구 코드의 경우 개수가 상당히 많아, DB로 관리하는 것도 좋았다고 생각이 듭니다.

## 인증 관련

토큰 관련하여 Argument Resolver와 Intercepter를 두어 매번 컨트롤러에서 validation없이 한 곳에서 코드가 관리되도록 구성하였습니다.

## interface 관련
여행 관련 어플리케이션에서 요구사항이 변동된다면 인터페이스 설계 자체가 바뀌어야하는 경우가 대부분일 것이고, 

여러 구현체가 필요치 않다고 판단했습니다. 따라서 인증 인가를 제외하고는 별도의 인터페이스를 두지 않고 클래스를 두었습니다.

## 예외 코드 관련 
비지니스 오류의 경우 별도의 서버 오류로 처리해야되기 때문에 에러코드를 관리하는 Enum객체와 이를 가지는 비지니스 Exception은 하나만 두어 

예외관련 불필요한 클래스가 너무 많아지는 것을 방지하고자 했습니다. 또한 ExceptionAdvice를 통해 에러 처리를 한 곳에서 관리하고자 하였습니다.

## 객체 Mapping 
Entity <-> 도메인간의 맵핑 로직이 Service단에 너무 많아지는 경우, 서비스의 핵심로직을 판단하는것을 방해한다 생각이 들었습니다.

따라서 이는 DTO에 팩토리 패턴을 적용하고 책임을 DTO에 두어, 서비스 레이어에서는 최대한 비지니스 로직만 남기려고 노력하였습니다. 

